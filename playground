#!/usr/bin/bash

interactive_mode=false

# And also variables from config file 

###############################################################################
# -- FUNCTIONS
# -----------------------------------------------------------------------------
# -- UTILS
# -----------------------------------------------------------------------------

cecho() {
  if [[ $2 = first_line ]]; then
    echo "[$(idate)] $1" | tee install.log
  else
    echo "[$(idate)] $1" | tee -a install.log
  fi
}

idate() {
  date +"%Y-%m-%d %H:%M:%S"
}


load_config() {
  local config_file="./install.config"

  # Load default config if custom one is not specified
  cecho "Loading config file..." first_line
  if [[ -z $1 ]]; then
    source $config_file
  else
    config_file=$1
    source $1
  fi

  # Check if config file was loaded successfully
  if [[ $? -eq 0 ]]; then
    cecho "Load config file $config_file: SUCCESS"
  else
    cecho "Load config file $config_file: FAILED"
    exit 1
  fi
}


usage() {
  echo "Usage: $0 [OPTIONS]"
  echo "Options:"
  echo " -h --help          Display this message"
  echo " -i --interactive   Enable interactive mode"
  echo " --config=file      Path to onfig file"
}

handle_flags() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h | --help)
        usage
        exit 1
        ;;
      -i | --interactive)
        interactive_mode=true
        shift
        ;;
      --config*)
        if ! [[ $1 == *=* && -n ${1#*=} ]]; then
          echo "No config file provided"
          usage
          exit 1
        fi

        load_config "${1#*=}"
        shift
        ;;
      *)
        usage
        exit 1
        ;;
    esac
  done
}


check_uefi_boot() {
  # Check if we're in the UEFI mode
  ls /sys/firmware/efi/efivars > commands.log 2> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "System in UEFI mode: SUCCESS"
  else
    cecho "System in UEFI mode: FAILED"
    cecho "ONLY INSTALL IN UEFI MODE IS SUPPORTED"
    exit 1
  fi
}


# -----------------------------------------------------------------------------
# -- NETWORK
# -----------------------------------------------------------------------------

validate_ip_address() {
  local ip_addr=""
  # IP address without subnet mask
  for oct in "$1" "$2" "$3" "$4"; do
    case $oct in
      ""|*[!0123456789]*)
        echo "invalid"
        exit 1
    esac
  done
  ip_addr="$1.$2.$3.$4"

  # IP address with subnet mask
  if [[ $# -eq 5 ]]; then
    case $5 in
      ""|*[!0123456789]*)
        echo "invalid"
        exit 1
    esac

    ip_addr="$1.$2.$3.$4/$5"
  fi

  if [[ $1 -ge 0 && $1 -le 255 && \
        $2 -ge 0 && $2 -le 255 && \
        $3 -ge 0 && $3 -le 255 && \
        $4 -ge 0 && $4 -le 255 && \
        $5 -ge 0 && $5 -le 32 ]]
  then echo "$ip_addr"
  else echo "invalid"; fi
}


net_scan_interfaces() {
  local interfaces=""
  local active_int=""

  if [[ $interactive_mode = false ]]; then
    # Priority goes from top to bottom
    # Top    - the least important
    # Bottom - the most important
    # ------------------------------------
    # net_use_wireless    -   config variable
    # net_allow_gsm       -   config variable
    # net_use_cable       -   config variable
    # net_interface       -   config variable


    # Exclude all interfaces from the list that are not WiFi - P1
    if [[ $net_use_wireless = true ]]; then
      interfaces=$(ip --brief link | awk '$1 !~ "lo|vir|lxd|docker|tail|enp|eth|wwp" {print $1}')
    fi

    # Exclude all interfaces from the list that are not GSM (it will override wifi settings) - P2
    if [[ $net_allow_gsm = true ]]; then
      interfaces=$(ip --brief link | awk '$1 !~ "lo|vir|lxd|docker|tail|enp|eth|wl" {print $1}')
    fi

    # Exclude all interfaces from the list that are not cable connections - P3
    if [[ ($net_use_wireless = false && $net_allow_gsm = false) || $net_use_cable = true ]]; then
      interfaces=$(ip --brief link | awk '$1 !~ "lo|vir|lxd|docker|tail|wl|wwp" {print $1}')
    fi

    # Check if network interface has been declared in the config file - P4
    if [[ -n $net_interface ]]; then active_int=$net_interface; fi
  else
    # Scan all interfaces
    interfaces=$(ip --brief link | awk '$1 !~ "lo" {print $1}')

    # Ask for wifi SSID and password
    if [[ $net_use_wireless = true && $net_allow_gsm = false ]]; then
      read -p "Wifi network SSID: " net_wifi_ssid
      read -s -p "Wifi network password: " net_wifi_pass
      echo >&2
    fi
  fi

  # Check if default interface has been set, if not, return all specified above
  if [[ -n $active_int ]]; then echo "$active_int"
  else echo "$interfaces"; fi
}


net_interface_status() {
  cat /sys/class/net/"$1"/operstate
}

net_wifi_connect() {
  # net_wifi_ssid   -   config variable
  # net_wifi_pass   -   config variable

  # Try to connect to the wifi network
  echo -e "station $int connect ${net_wifi_ssid}\n${net_wifi_pass}" | iwctl >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "Connect to WiFi network ${net_wifi_ssid} using interface $1: SUCCESS" >&2
    local int_status=$(net_interface_status "$1")
    if [[ $int_status = "up" ]]; then echo "$int_status"; fi
  else
    cecho "Connect to WiFi network ${net_wifi_ssid} using interface $1: FAILED" >&2
    return -1
  fi
}

net_check_interfaces() {
  local ints=($1)
  local int_status=""

  local cnt=0
  if [[ ${#ints[@]} -gt 1 ]]; then  
    # Check every interface from the list
    for int in ${ints[@]}; do
      int_status=$(net_interface_status "$int")
      
      echo "$cnt) $int: $int_status" >&2
      cnt=$((cnt + 1))

      if [[ $net_use_wireless = true && $net_allow_gsm = false ]]; then
        local status=$(net_wifi_connect "$int")
        if [[ $status = "up" ]]; then echo "$int"; break; fi
      fi

      if [[ $int_status = "up" && $interactive_mode = false ]]; then
        echo "$int"
        break
      fi
    done
  else 
    # If there is only one interface, we just check if it's up
    int_status=$(net_interface_status "$1")
    if [[ $? -ne 0 ]]; then return -1; fi             # Cannot get int status
    if [[ $int_status = "up" ]]; then echo "$1"; fi   # Return running interface
  fi
}

net_interface_config() {
  # net_ip_address    -   config variable
  # net_gateway       -   config variable
  # active_int        -   config variable
  # net_nameservers   -   config variable

  cecho "No active links detected, configuring..."

  # Add IP address to the interface
  ip address add $net_ip_address broadcast + dev ${1} >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "Add address ${net_ip_address} to interface ${1}: SUCCESS"
  else
    cecho "Add address ${net_ip_address} to interface ${1}: FAILED"
    exit 1
  fi

  # Add default gateway
  ip route add default via $net_gateway >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "Add default gateway $net_gateway via ${1}: SUCCESS"
  else
    cecho "Add default gateway $net_gateway via ${1}: FAILED"
    cecho "[WARNING] Possibly no direct connection to the network"
  fi

  ip link set ${1} up >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "Bring link ${1} UP: SUCCESS"
  else
    cecho "Bring link ${1} UP: FAILED"
    exit 1
  fi


  # Add DNS servers
  if [[ ${#net_nameservers[@]} -gt 1 ]]; then
    for dns in ${net_nameservers[@]}; do
      echo "nameserver $dns" >> /etc/resolv.conf | tee -a install.log
    done
  else
    echo "nameserver $net_nameservers" >> /etc/resolv.conf | tee -a install.log
  fi

  if [[ $? -eq 0 ]]; then
    cecho "Add DNS server $net_nameservers: SUCCESS"
  else
    cecho "Add DNS server $net_nameservers: FAILED"
    exit 1
  fi
}

net_check_connection() {
  # net_gateway   -   config variable

  # Check connection to gateway
  local gateways=$(ip route | awk '/default/ {print $3}')
  gateways=($gateways)

  if [[ ${#gateways[@]} -gt 1 ]]; then
    # More than one gateway detected
    cecho "[WARNING] More than one gateway!"
    for gate in ${gateways[@]}; do
      ping -c 4 $gate >> commands.log 2>> errors.log
      
      if [[ $? -eq 0 ]]; then 
        # To be changed: break loop on first successfull ping
        gateways=$gate
        break 
      fi
    done
  else
    # Only one gateway detected
    if [[ -n $gateways ]]; then net_gateway=$gateways; fi
    ping -c 4 $net_gateway >> commands.log 2>> errors.log
  fi


  if [[ $? -eq 0 ]]; then
    cecho "Route to gateway $net_gateway: SUCCESS"

    # Check connection to the internet and DNS resolving
    ping -c 4 google.com >> commands.log 2>> errors.log
    if [[ $? -eq 0 ]]; then
      cecho "Route to google.com: SUCCESS"
    else
      cecho "Route to google.com: FAILED"
      exit 1
    fi
  else
    cecho "Route to gateway $net_gateway: FAILED"
    exit 1
  fi
}


# -----------------------------------------------------------------------------
# -- STORAGE
# -----------------------------------------------------------------------------

disk_clean_drive() {
  # disk root       -   config variable
  # disk home       -   config variable
  # disk_lvm_root   -   config variable
  # disk_lvm_home   -   config variable

  # Clean eventual leftovers
  local disk=""
  if [[ $1 = "STANDARD" ]]; then
    disk=$(pvs | awk -v d="$disk_root" '$1 ~ d {print $2}')
    if [[ -n $disk ]]; then
      yes | vgremove $disk 2>> errors.log
    fi

    ls $disk_root* | xargs -n1 umount -l >> commands.log 2>> errors.log
    wipefs --all --force $disk_root >> commands.log 2>> errors.log


    disk=$(pvs | awk -v d="$disk_home" '$1 ~ d {print $2}')
    if [[ -n $disk ]]; then
      yes | vgremove $disk 2>> errors.log
    fi

    ls $disk_home* | xargs -n1 umount -l >> commands.log 2>> errors.log
    wipefs --all --force $disk_home >> commands.log 2>> errors.log
  fi

  if [[ $1 = "LVM" ]]; then
    ls /dev/mapper/* | xargs -n1 umount -l >> commands.log 2>> errors.log

    for drive in ${disk_lvm_root[@]} ${disk_lvm_home[@]}; do
      disk=$( { pvs | awk -v d="$drive" '$1 ~ d {print $2}' ; } 2>/dev/null )
      if [[ -n $disk ]]; then
        yes | vgremove $disk >> commands.log 2>> errors.log
      fi

      ls $drive* | xargs -n1 umount -l >> commands.log 2>> errors.log
      wipefs --all --force $drive >> commands.log 2>> errors.log
    done
  fi

  # In case there was LUKS before
  disk=$(lsblk | awk '$6 ~ "crypt" {print substr($1,3)}')
  if [[ -n $disk ]]; then
    cryptsetup luksClose $disk >> commands.log 2>> errors.log
  fi
}

disk_create_partition() {
  echo n      # Create new partition
  echo        # Partition number (accept default)
  echo        # First sector (accept deafult)
  echo $1     # Last sector (partition size)
  echo $2     # Partition code (eg. EF00, 8300, 8E00 etc.)
}

disk_format_drive() {
  # disk_esp_size         -   config variable
  # disk_root             -   config variable
  # disk_root_size        -   config variable
  # disk_separate_home    -   config variable
  # disk_home             -   config variable
  # disk_home_size        -   config variable
  # disk_lvm_root         -   config variable
  # disk_lvm_home         -   config variable

  local free_space="100FREE"
  disk_clean_drive "$1"


  local root_size=""
  local home_size=""

  if [[ $1 = "STANDARD" ]]; then
    # Use standard disk partitioning
    ( 
      # ESP partition
      echo o    # Create new partition table
      echo Y    # Confirm partition table
      disk_create_partition "$disk_esp_size" EF00

      # root partition
      if [[ $disk_root_size = $free_space ]]; then 
        root_size=    # Use 100% of the free space
      else 
        root_size=$disk_root_size
      fi 
      disk_create_partition "$root_size" 8300

      # /home on the same disk
      if [[ $disk_separate_home = false ]]; then
        if [[ $disk_home_size = $free_space ]]; then 
          home_size=    # Use 100% of the free space
        else 
          home_size=$disk_home_size
        fi 
        disk_create_partition "$home_size" 8300
      fi

      echo w    # Save changes to disk
      echo Y    # Confirm changes
    ) | gdisk $disk_root >> commands.log 2>> errors.log

    if [[ $? -eq 0 ]]; then
      cecho "Standard disk partitioning | $disk_root: SUCCESS"
    else
      cecho "Standard disk partitioning | $disk_root: FAILED"
      exit 1
    fi

    if [[ $disk_separate_home = true ]]; then
      (
        # /home on the separate disk
        echo o
        echo Y

        if [[ $disk_home_size = $free_space ]]; then 
          home_size=    # Use 100% of the free space
        else 
          home_size=$disk_home_size
        fi 
        disk_create_partition "$home_size" 8300

        echo w
        echo Y
      ) | gdisk $disk_home >> commands.log 2>> errors.log

      if [[ $? -eq 0 ]]; then
        cecho "Standard disk partitioning | $disk_home: SUCCESS"
      else
        cecho "Standard disk partitioning | $disk_home: FAILED"
        exit 1
      fi
    fi
  fi


  if [[ $1 = "LVM" ]]; then
    # Use LVM only or LVM + LUKS
    local free=

    for cnt in ${!disk_lvm_root[@]}; do
      if [[ $cnt -eq 0 ]]; then
        (
          # ESP partition on the first disk from root LVM group
          echo o
          echo Y
          disk_create_partition "$disk_esp_size" EF00
          disk_create_partition "$free" 8E00
          echo w
          echo Y
        ) | gdisk ${disk_lvm_root[0]} >> commands.log 2>> errors.log
      else
        (
          echo o
          echo Y
          disk_create_partition "$free" 8E00
          echo w
          echo Y
        ) | gdisk ${disk_lvm_root[$cnt]} >> commands.log 2>> errors.log
      fi

      if [[ $? -eq 0 ]]; then
        cecho "LVM disk partitioning | ${disk_lvm_root[$cnt]}: SUCCESS"
      else
        cecho "LVM disk partitioning | ${disk_lvm_root[$cnt]}: FAILED"
        exit 1
      fi
    done

    for cnt in ${!disk_lvm_home[@]}; do
      (
        echo o
        echo Y
        disk_create_partition "$free" 8E00
        echo w
        echo Y
      ) | gdisk ${disk_lvm_home[$cnt]} >> commands.log 2>> errors.log

      if [[ $? -eq 0 ]]; then
        cecho "LVM disk partitioning | ${disk_lvm_home[$cnt]}: SUCCESS"
      else
        cecho "LVM disk partitioning | ${disk_lvm_home[$cnt]}: FAILED"
        exit 1
      fi
    done
  fi
}

disk_list_drives() {
  # Show all drives
  local models=($(fdisk -l | awk '$2 ~ "model" {print $3" "$4" "$5}'))
  if [[ $? -ne 0 || -z $models ]]; then
    cecho "[WARNING] Cannot get drive model!" >&2
  fi

  local sizes=($(fdisk -l | awk '($4 ~ "TiB" || $4 ~ "GiB" || $4 ~ "MiB") && $2 !~ "loop|mapper" {print $3" "$4}'))
  if [[ $? -ne 0 || -z $sizes ]]; then
    cecho "[WARNING] Cannot get drive size!" >&2
  fi
  
  local drives=($(lsblk | awk '$1 !~ "NAME|-" && $1 !~ /[0-9]/ && $6 !~ "lvm|crypt" || ($1 ~ /nvme/ && $1 !~ /p/) {print $1}'))
  if [[ $? -ne 0 || -z $drives ]]; then
    cecho "Get list of all drives: FAILED" >&2
    exit 1
  fi  

  local cnt=0
  local pos_cnt=0
  local disk_drives=()

  for drive in ${drives[@]}; do
    echo -n "${cnt}) " >&2
    echo -n "${models[$pos_cnt]} ${models[$((pos_cnt + 1))]} " >&2
    echo -n "| ${sizes[$pos_cnt]} ${sizes[$((pos_cnt + 1))]} | " >&2
    echo "$drive" >&2

    cnt=$((cnt + 1))
    pos_cnt=$((pos_cnt + 2))
    disk_drives+=("$drive")
  done

  echo "${disk_drives[@]}"  # return value
}

disk_root_drives() {
  # -- disk_use_lvm         -   config variable
  # -- disk_root            -   config variable
  # -- disk_separate_home   -   config variable

  local drives=("$1")

  # We want to read numbers only
  local user_choice=-1
  if [[ $disk_use_lvm = false ]]; then
    while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#drives[@]} ]]; do
      read -p "Choose root drive: " user_choice
    done


    # We want Y/N only
    local answer=-1
    while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
      read -p "Use separate drive for /home? (Y/N): " answer
    done
    if [[ ${answer,,} =~ ^y(es)?$ ]]; then 
      disk_separate_home=true 
    else
      disk_separate_home=false
    fi


    disk_root="/dev/${$1[$user_choice]}"
    echo "$disk_root"   # return value
  else
    while read -p "Choose root drives (Enter to continue): " user_choice; do
      # Catch empty string and invalid input
      if [[ -z $user_choice && ${#disk_lvm_root[@]} -gt 0 ]]; then
        break
      elif [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#drives[@]} ]]; then
        continue
      else
        # Add drive to LVM group
        disk_lvm_root+=(/dev/${$1[$user_choice]})
      fi
    done

    echo "${disk_lvm_root[@]}"  # return value
  fi
}

disk_home_drives() {
  # -- disk_use_lvm   -   config variable
  # -- disk_home      -   config variable

  local drives=("$1")

  if [[ $disk_use_lvm = false ]]; then
    # We want to read numbers only
    local user_choice=-1
    while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#drives[@]} ]]; do
      read -p "Choose /home drive: " user_choice
    done

    disk_home="/dev/${$1[$user_choice]}"
    echo "$disk_home"   # return value
  else
    while read -p "Choose /home drives (Enter to continue): " user_choice; do
      # Catch empty string and invalid input
      if [[ -z $user_choice && ${#disk_lvm_home[@]} -gt 0 ]]; then
        break
      elif [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#drives[@]} ]]; then
        continue
      else
        # Add drive to LVM group
        disk_lvm_home+=(/dev/${$1[$user_choice]})
      fi
    done
  
    echo "${disk_lvm_home[@]}"  # return value
  fi
}

disk_part_size() {
  # We want to read numbers only
  local user_choice=-1
  while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 ]]; do
    read -p "Choose $1 size (GiB or 0 for 100%FREE): " user_choice
  done

  local disk_size=""
  if [[ user_choice -eq 0 ]]; then
    disk_size=100FREE   # Use 100% of free space
  else
    disk_size="${user_choice}G"
  fi

  echo "$disk_size"   # return value
}

disk_part_mkfs() {
  ls $1 | xargs -n1 umount -l >> commands.log 2>> errors.log
  wipefs --force --all $1 >> commands.log 2>> errors.log
  yes | mkfs.$2 $1 >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "$3 Partition format ($2): SUCCESS"
  else
    cecho "$3 partition format ($2): FAILED"
    exit 1
  fi
}

disk_lvm_pv() {
  if [[ $1 = "ROOT" ]]; then
    local drives_root=()
    for cnt in ${!disk_lvm_root[@]}; do
      # Partition on the drive with ESP
      if [[ $cnt -eq 0 ]]; then
        drives_root+=(${disk_lvm_root[$cnt]}2)
        yes | pvcreate -ff ${disk_lvm_root[$cnt]}2 >> commands.log 2>> errors.log
      fi

      # Every next root partition
      if [[ $cnt -gt 0 && ${#disk_lvm_root[@]} -gt 1 ]]; then
        drives_root+=(${disk_lvm_root[$cnt]}1)
        yes | pvcreate -ff ${disk_lvm_root[$cnt]}1 >> commands.log 2>> errors.log
      fi

      if [[ $? -eq 0 ]]; then
        cecho "LVM Physical Volume (${drives_root[$cnt]}) create: SUCCESS" >&2
      else
        cecho "LVM Physical Volume (${drives_root[$cnt]}) create: FAILED" >&2
        exit 1
      fi
    done

    echo "${drives_root[@]}"    # return value
  fi

  if [[ $1 = "HOME" ]]
    local drives_home=()
    for cnt in ${!disk_lvm_home[@]}; do
      drives_home+=(${disk_lvm_home[$cnt]}1)
      yes | pvcreate -ff ${disk_lvm_home[$cnt]}1 >> commands.log 2>> errors.log

      if [[ $? -eq 0 ]]; then
        cecho "LVM Physical Volume (${drives_home[$cnt]}) create: SUCCESS" >&2
      else
        cecho "LVM Physical Volume (${drives_home[$cnt]}) create: FAILED" >&2
        exit 1
      fi
    done

    echo "${drives_home[@]}"    # return value
  fi
}

disk_lvm_vg() {
  local vgs=("$2")
  yes | vgcreate $1 ${vgs[@]} >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "LVM Volume Group ($1) create: SUCCESS"
  else
    cecho "LVM Volume Group ($1) create: FAILED"
    exit 1
  fi
}

disk_lvm_lv() {
  yes | lvcreate -l 100%FREE -n $1 $2 >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "LVM Logical Volume ($1) create: SUCCESS"
  else
    cecho "LVM Logical Volume ($1) create: FAILED"
    exit 1
  fi
}

disk_luks_part() {
  echo $disk_luks_pass | cryptsetup -q luksFormat --type luks2 $1
  
  if [[ $? -eq 0 ]]; then
    cecho "Encrypted partition ($1) create: SUCCESS"
  else
    cecho "Encrypted partition ($1) create: FAILED"
    exit 1
  fi

  echo $disk_luks_pass | cryptsetup luksOpen $1 $disk_luks_root_name
  root_part=/dev/mapper/$disk_luks_root_name

  if [[ $? -eq 0 ]]; then
    cecho "Decrypt partition ($1) and ready it to mount: SUCCESS"
  else
    cecho "Decrypt partition ($1) and ready it to mount: FAILED"
    exit 1
  fi

  echo "$root_part"   # return value
}

disk_part_mount() {
  mount $1 $2
  if [[ $? -eq 0 ]]; then
    cecho "$3 partition ($1) mount: SUCCESS"
  else
    cecho "$3 partition ($1) mount: FAILED"
    exit 1
  fi
}


###############################################################################
# -- MAIN FUNCTION
###############################################################################

main() {
  # Load default config file only in non-interactive mode, 
  # only without custom one provided
  if [[ $1 -eq 0 ]]; then load_config; fi
  
  check_uefi_boot
  

  #############################################################################
  # -- NETWORK
  # ---------------------------------------------------------------------------

  echo
  cecho "Checking for network..."
  local interfaces=$(net_scan_interfaces)
  local active_int=$(net_check_interfaces "$interfaces")
  if [[ -n $active_int ]]; then
    local int_status=$(net_interface_status "$active_int")
  fi

  # If it returns -1, we know that we passed only one interface and it's down
  if [[ $active_int -eq -1 ]]; then cecho "Get $interfaces status: FAILED"; fi


  if [[ $interactive_mode = true ]]; then
    # If interactive mode is enabled, we don't care what's in the config
    local ints=($interfaces)

    # We want to read numbers only
    local user_choice=-1
    while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#ints[@]} ]]; do
      read -p "Choose interface: " user_choice
    done

    active_int=${ints[$user_choice]}
    int_status=$(cat /sys/class/net/"$active_int"/operstate)
  fi


  if [[ $int_status = "up" ]]; then
    cecho "Interface $active_int: $int_status"
  else
    # IP address config on interface
    if [[ $interactive_mode = true ]]; then
      local ipa="invalid"
      while [[ $ipa = "invalid" ]]; do
        IFS='./' read -rp "IP address (CIDR): " a b c d e
        ipa=$(validate_ip_address $a $b $c $d $e)
      done
      net_ip_address=$ipa   # config variable
      
      ipa="invalid"
      while [[ $ipa = "invalid" ]]; do
        IFS='./' read -rp "Default gateway: " a b c d
        ipa=$(validate_ip_address $a $b $c $d)
      done
      net_gateway=$ipa      # config variable

      ipa="invalid"
      while [[ $ipa = "invalid" ]]; do
        IFS='./' read -rp "DNS server: " a b c d
        ipa=$(validate_ip_address $a $b $c $d)
      done
      net_nameserver=($ipa)   # config variable
    fi

    net_interface_config "$active_int"
  fi

  net_check_connection


  #############################################################################
  # -- STORAGE
  # ---------------------------------------------------------------------------
  # -- disk_use_lvm     -   config variable
  # -- disk_use_luks    -   config variable
  # -- disk_lvm_root    -   config variable
  # -- disk_lvm_home    -   config variable
  # -- disk_root        -   config variable
  # -- disk_home        -   config variable
  # -- disk_esp_size    -   config variable
  # -- disk_root_size   -   config variable
  # -- disk_home_size   -   config variable
  # ---------------------------------------------------------------------------
  # -- PARTITIONING
  # ---------------------------------------------------------------------------


  if [[ $interactive_mode = true ]]; then
    # Ugly workaround, to be changed
    disk_use_lvm=false
    disk_use_luks=false
    disk_lvm_root=()
    disk_lvm_home=()


    # We want Y/N only
    local answer=-1
    while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
      read -p "Do you want to use LVM? (Y/N): " answer
    done
    if [[ ${answer,,} =~ ^y(es)?$ ]]; then disk_use_lvm=true; fi
    
    answer=-1
    while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
      read -p "Do you want to use LUKS? (Y/N): " answer
    done
    if [[ ${answer,,} =~ ^y(es)?$ ]]; then 
      if [[ $disk_use_lvm = false ]]; then
        cecho "[WARNING] LUKS supported only in the LVM mode!"
        cecho "LVM mode has been enabled."
        disk_use_lvm=true 
      fi
      
      disk_use_luks=true
    fi


    # We want to read numbers only
    local user_choice=-1
    while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 ]]; do
      read -p "Choose ESP size (MiB): " user_choice
    done
    disk_esp_size="${user_choice}M"


    local disk_drives=$(disk_list_drives)
    local root_drives=$(disk_root_drives "$disk_drives")
    if [[ $disk_separate_home = true || $disk_use_lvm = true ]]; then
      local home_drives=$(disk_home_drives "$disk_drives")
    fi

    if [[ $disk_use_lvm = true ]]; then
      disk_root=${root_drives[0]}
      disk_lvm_root=${root_drives[@]}
      disk_lvm_home=${home_drives[@]}
    else
      disk_root=$root_drives
      disk_home=$home_drives
    fi

    disk_root_size=$(disk_part_size "root")
    disk_home_size=$(disk_part_size "home")
  else
    disk_root=${disk_lvm_root[0]}
  fi


  local esp_part=""
  local root_part=""
  local home_part=""

  # It does only matter without LVM or LUKS
  if [[ ${disk_root} =~ /nvme/ ]]; then
    esp_part=${disk_root}p1     # eg. /dev/nvme0n1p1
    if [[ $disk_separate_home = true ]]; then
      root_part=${disk_root}p2    # eg. /dev/nvme0n1p2
    else
      root_part=${disk_root}p2    # eg. /dev/nvme0n1p2
      home_part=${disk_root}p3    # eg. /dev/nvme0n1p3
    fi
  else
    esp_part=${disk_root}1      # eg. /dev/sda1
    if [[ $disk_separate_home = true ]]; then
      root_part=${disk_root}2     # eg. /dev/sda2
    else
      root_part=${disk_root}2     # eg. /dev/sda2
      home_part=${disk_root}3     # eg. /dev/sda3
    fi
  fi
  
  if [[ $disk_use_lvm = true ]]; then
    disk_format_drive "LVM"
  else
    disk_format_drive "STANDARD"
  fi


  # ---------------------------------------------------------------------------
  # -- FORMATTING
  # ---------------------------------------------------------------------------
  # -- disk_root_fs           -   config variable
  # -- disk_lvm_root_group    -   config variable
  # -- disk_lvm_root_volume   -   config variable
  # -- disk_home_fs           -   config variable
  # -- disk_lvm_home_group    -   config variable
  # -- disk_lvm_home_volume   -   config variable
  # -- disk_use_lvm           -   config variable
  # -- disk_use_luks          -   config variable
  # -- disk_luks_pass         -   config variable
  # -- disk_luks_root_name    -   config variable
  # ---------------------------------------------------------------------------

  if [[ $disk_use_lvm = true ]]; then
    root_drives=()
    home_drives=()
    
    if [[ $interactive_mode = true ]]; then
      read -p "Choose root group name (eg. root): " disk_lvm_root_group
      read -p "Choose home group name (eg. home): " disk_lvm_home_group
    fi

    root_drives=$(disk_lvm_pv "ROOT")
    home_drives=$(disk_lvm_pv "HOME")

    disk_lvm_vg "$disk_lvm_root_group" "${root_drives[@]}"
    disk_lvm_vg "$disk_lvm_home_group" "${home_drives[@]}"

    if [[ $interactive_mode = true ]]; then
      read -p "Choose root volume name (eg. proot): " disk_lvm_root_volume
      read -p "Choose home volume name (eg. phome): " disk_lvm_home_volume
    fi

    disk_lvm_lv "$disk_lvm_root_volume" "$disk_lvm_root_group"
    disk_lvm_lv "$disk_lvm_home_volume" "$disk_lvm_home_group"

    root_part=/dev/$disk_lvm_root_group/$disk_lvm_root_volume
    home_part=/dev/$disk_lvm_home_group/$disk_lvm_home_volume
  fi

  
  if [[ $disk_use_luks = true ]]; then
    if [[ $interactive_mode = true ]]; then 
      read -s -p "Choose encryption password: " disk_luks_pass
      echo
      read -p "Choose LUKS root partition name (eg. cryptroot): " disk_luks_root_name
    fi

    root_part=$(disk_luks_part "$root_part")
  fi


  disk_part_mkfs "$esp_part" "vfat" "ESP"

  if [[ $interactive_mode = true ]]; then
    read -p "Choose root filesystem (ext4, xfs, btrfs etc.): " disk_root_fs
    read -p "Choose /home filesystem (ext4, xfs, btrfs etc.): " disk_home_fs
  fi

  disk_part_mkfs "$root_part" "$disk_root_fs" "root"
  disk_part_mkfs "$home_part" "$disk_home_fs" "home"

  disk_part_mount "$root_part" "/mnt" "Root"
  
  mkdir /mnt/boot
  disk_part_mount "$esp_part" "/mnt/boot" "Boot"

  mkdir /mnt/home
  disk_part_mount "$home_part" "/mnt/home" "Home"
}

handle_flags "$@"
main "$#"