#!/usr/bin/bash

interactive_mode=false
export disk_separate_home=""

# And also variables from config file 

###############################################################################
# -- FUNCTIONS
# -----------------------------------------------------------------------------
# -- UTILS
# -----------------------------------------------------------------------------

cecho() {
  if [[ $2 = first_line ]]; then
    echo "[$(idate)] $1" | tee install.log
  else
    echo "[$(idate)] $1" | tee -a install.log
  fi
}

idate() {
  date +"%Y-%m-%d %H:%M:%S"
}


load_config() {
  local config_file="./install.config"

  # Load default config if custom one is not specified
  cecho "Loading config file..." first_line
  if [[ -z $1 ]]; then
    source $config_file
  else
    config_file=$1
    source $1
  fi

  # Check if config file was loaded successfully
  if [[ $? -eq 0 ]]; then
    cecho "Load config file $config_file: SUCCESS"
  else
    cecho "Load config file $config_file: FAILED"
    exit 1
  fi
}


usage() {
  echo "Usage: $0 [OPTIONS]"
  echo "Options:"
  echo " -h --help          Display this message"
  echo " -i --interactive   Enable interactive mode"
  echo " --config=file      Path to onfig file"
}

handle_flags() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h | --help)
        usage
        exit 1
        ;;
      -i | --interactive)
        interactive_mode=true
        shift
        ;;
      --config*)
        if ! [[ $1 == *=* && -n ${1#*=} ]]; then
          echo "No config file provided"
          usage
          exit 1
        fi

        load_config "${1#*=}"
        shift
        ;;
      *)
        usage
        exit 1
        ;;
    esac
  done
}


check_uefi_boot() {
  # Check if we're in the UEFI mode
  ls /sys/firmware/efi/efivars > commands.log 2> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "System in UEFI mode: SUCCESS"
  else
    cecho "System in UEFI mode: FAILED"
    cecho "ONLY INSTALL IN UEFI MODE IS SUPPORTED"
    exit 1
  fi
}


# -----------------------------------------------------------------------------
# -- NETWORK
# -----------------------------------------------------------------------------

validate_ip_address() {
  local ip_addr=""
  # IP address without subnet mask
  for oct in "$1" "$2" "$3" "$4"; do
    case $oct in
      ""|*[!0123456789]*)
        echo "invalid"
        exit 1
    esac
  done
  ip_addr="$1.$2.$3.$4"

  # IP address with subnet mask
  if [[ $# -eq 5 ]]; then
    case $5 in
      ""|*[!0123456789]*)
        echo "invalid"
        exit 1
    esac

    ip_addr="$1.$2.$3.$4/$5"
  fi

  if [[ $1 -ge 0 && $1 -le 255 && \
        $2 -ge 0 && $2 -le 255 && \
        $3 -ge 0 && $3 -le 255 && \
        $4 -ge 0 && $4 -le 255 && \
        $5 -ge 0 && $5 -le 32 ]]
  then echo "$ip_addr"
  else echo "invalid"; fi
}


net_scan_interfaces() {
  local interfaces=""
  local active_int=""

  if [[ $interactive_mode = false ]]; then
    # Priority goes from top to bottom
    # Top    - the least important
    # Bottom - the most important
    # ------------------------------------
    # net_use_wireless    -   config variable
    # net_allow_gsm       -   config variable
    # net_use_cable       -   config variable
    # net_interface       -   config variable


    # Exclude all interfaces from the list that are not WiFi - P1
    if [[ $net_use_wireless = true ]]; then
      interfaces=$(ip --brief link | awk '$1 !~ "lo|vir|lxd|docker|tail|enp|eth|wwp" {print $1}')
    fi

    # Exclude all interfaces from the list that are not GSM (it will override wifi settings) - P2
    if [[ $net_allow_gsm = true ]]; then
      interfaces=$(ip --brief link | awk '$1 !~ "lo|vir|lxd|docker|tail|enp|eth|wl" {print $1}')
    fi

    # Exclude all interfaces from the list that are not cable connections - P3
    if [[ ($net_use_wireless = false && $net_allow_gsm = false) || $net_use_cable = true ]]; then
      interfaces=$(ip --brief link | awk '$1 !~ "lo|vir|lxd|docker|tail|wl|wwp" {print $1}')
    fi

    # Check if network interface has been declared in the config file - P4
    if [[ -n $net_interface ]]; then active_int=$net_interface; fi
  else
    # Scan all interfaces
    interfaces=$(ip --brief link | awk '$1 !~ "lo" {print $1}')

    # Ask for wifi SSID and password
    if [[ $net_use_wireless = true && $net_allow_gsm = false ]]; then
      read -p "Wifi network SSID: " net_wifi_ssid
      read -s -p "Wifi network password: " net_wifi_pass
      echo >&2
    fi
  fi

  # Check if default interface has been set, if not, return all specified above
  if [[ -n $active_int ]]; then echo "$active_int"
  else echo "$interfaces"; fi
}


net_interface_status() {
  cat /sys/class/net/"$1"/operstate
}

net_wifi_connect() {
  # net_wifi_ssid   -   config variable
  # net_wifi_pass   -   config variable

  # Try to connect to the wifi network
  echo -e "station $int connect ${net_wifi_ssid}\n${net_wifi_pass}" | iwctl >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "Connect to WiFi network ${net_wifi_ssid} using interface $1: SUCCESS" >&2
    local int_status=$(net_interface_status "$1")
    if [[ $int_status = "up" ]]; then echo "$int_status"; fi
  else
    cecho "Connect to WiFi network ${net_wifi_ssid} using interface $1: FAILED" >&2
    return -1
  fi
}

net_check_interfaces() {
  local ints=($1)
  local int_status=""

  local cnt=0
  if [[ ${#ints[@]} -gt 1 ]]; then  
    # Check every interface from the list
    for int in ${ints[@]}; do
      int_status=$(net_interface_status "$int")
      
      echo "$cnt) $int: $int_status" >&2
      cnt=$((cnt + 1))

      if [[ $net_use_wireless = true && $net_allow_gsm = false ]]; then
        local status=$(net_wifi_connect "$int")
        if [[ $status = "up" ]]; then echo "$int"; break; fi
      fi

      if [[ $int_status = "up" && $interactive_mode = false ]]; then
        echo "$int"
        break
      fi
    done
  else 
    # If there is only one interface, we just check if it's up
    int_status=$(net_interface_status "$1")
    echo "0) $1: $int_status" >&2

    if [[ $? -ne 0 ]]; then return -1; fi             # Cannot get int status
    if [[ $int_status = "up" ]]; then echo "$1"; fi   # Return running interface
  fi
}

net_interface_config() {
  # net_ip_address    -   config variable
  # net_gateway       -   config variable
  # active_int        -   config variable
  # net_nameservers   -   config variable

  cecho "No active links detected, configuring..."

  # Add IP address to the interface
  ip address add $net_ip_address broadcast + dev ${1} >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "Add address ${net_ip_address} to interface ${1}: SUCCESS"
  else
    cecho "Add address ${net_ip_address} to interface ${1}: FAILED"
    exit 1
  fi

  # Add default gateway
  ip route add default via $net_gateway >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "Add default gateway $net_gateway via ${1}: SUCCESS"
  else
    cecho "Add default gateway $net_gateway via ${1}: FAILED"
    cecho "[WARNING] Possibly no direct connection to the network"
  fi

  ip link set ${1} up >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "Bring link ${1} UP: SUCCESS"
  else
    cecho "Bring link ${1} UP: FAILED"
    exit 1
  fi


  # Add DNS servers
  if [[ ${#net_nameservers[@]} -gt 1 ]]; then
    for dns in ${net_nameservers[@]}; do
      echo "nameserver $dns" >> /etc/resolv.conf | tee -a install.log
    done
  else
    echo "nameserver $net_nameservers" >> /etc/resolv.conf | tee -a install.log
  fi

  if [[ $? -eq 0 ]]; then
    cecho "Add DNS server $net_nameservers: SUCCESS"
  else
    cecho "Add DNS server $net_nameservers: FAILED"
    exit 1
  fi
}

net_check_connection() {
  # net_gateway   -   config variable

  # Check connection to gateway
  local gateways=$(ip route | awk '/default/ {print $3}')
  gateways=($gateways)

  if [[ ${#gateways[@]} -gt 1 ]]; then
    # More than one gateway detected
    cecho "[WARNING] More than one gateway!"
    for gate in ${gateways[@]}; do
      ping -c 4 $gate >> commands.log 2>> errors.log
      
      if [[ $? -eq 0 ]]; then 
        # To be changed: break loop on first successfull ping
        gateways=$gate
        break 
      fi
    done
  else
    # Only one gateway detected
    if [[ -n $gateways ]]; then net_gateway=$gateways; fi
    ping -c 4 $net_gateway >> commands.log 2>> errors.log
  fi


  if [[ $? -eq 0 ]]; then
    cecho "Route to gateway $net_gateway: SUCCESS"

    # Check connection to the internet and DNS resolving
    ping -c 4 google.com >> commands.log 2>> errors.log
    if [[ $? -eq 0 ]]; then
      cecho "Route to google.com: SUCCESS"
    else
      cecho "Route to google.com: FAILED"
      exit 1
    fi
  else
    cecho "Route to gateway $net_gateway: FAILED"
    exit 1
  fi
}


# -----------------------------------------------------------------------------
# -- STORAGE
# -----------------------------------------------------------------------------

disk_clean_drive() {
  # disk root       -   config variable
  # disk home       -   config variable
  # disk_lvm_root   -   config variable
  # disk_lvm_home   -   config variable

  # Clean eventual leftovers
  # local drives=$(lsblk | awk '{if ($1 !~ "NAME|loop|sr|-" && $1 ~ /[0-9]/){print $1}} if($6 ~ "lvm|crypt"){print $7}}' | tr -d '\├\─')
  local drives=$(lsblk | awk '$1 !~ "NAME|-|loop|sr" && $1 ~ /[0-9]/ {print $1}' | tr -d '\├\─') 
  local mounts=$(lsblk | awk '$1 !~ "NAME|loop|sr" && $6 ~ "lvm|crypt" {print $7}' | tr -d '\├\─')
  local disk=$(printf "/dev/%s " $drives)

  if [[ -n $mounts ]]; then umount -l $mounts >> commands.log 2>> errors.log; fi
  umount -l $disk >> commands.log 2>> errors.log
  
  # In case there was LUKS before
  disk=$(lsblk | awk '$6 ~ "crypt" {print substr($1,3)}')
  if [[ -n $disk ]]; then
    cryptsetup luksClose $disk >> commands.log 2>> errors.log
  fi
  
  wipefs --all --force $disk >> commands.log 2>> errors.log
  partprobe >> commands.log 2>> errors.log

  
  if [[ $1 = "STANDARD" ]]; then
    disk=$( { pvs | awk -v d="$disk_root" '$1 ~ d {print $2}' ; } 2>/dev/null )
    yes | vgremove $disk >> commands.log 2>> errors.log

    disk=$( { pvs | awk -v d="$disk_home" '$1 ~ d {print $2}' ; } 2>/dev/null )
    yes | vgremove $disk >> commands.log 2>> errors.log

    wipefs --all --force $disk_root >> commands.log 2>> errors.log
    wipefs --all --force $disk_home >> commands.log 2>> errors.log
  fi


  if [[ $1 = "LVM" ]]; then
    for drive in ${disk_lvm_root[@]} ${disk_lvm_home[@]}; do
      disk=$( { pvs | awk -v d="$drive" '$1 ~ d {print $2}' ; } 2>/dev/null )
      yes | vgremove $disk >> commands.log 2>> errors.log

      wipefs --all --force $drive >> commands.log 2>> errors.log
    done
  fi

  partprobe >> commands.log 2>> errors.log
}

disk_create_partition() {
  echo n      # Create new partition
  echo        # Partition number (accept default)
  echo        # First sector (accept deafult)
  echo $1     # Last sector (partition size)
  echo $2     # Partition code (eg. EF00, 8300, 8E00 etc.)
}

disk_format_drive() {
  # disk_esp_size         -   config variable
  # disk_root             -   config variable
  # disk_root_size        -   config variable
  # disk_separate_home    -   config variable
  # disk_home             -   config variable
  # disk_home_size        -   config variable
  # disk_lvm_root         -   config variable
  # disk_lvm_home         -   config variable

  local free_space="100FREE"
  disk_clean_drive "$1"


  local root_size=""
  local home_size=""

  if [[ $1 = "STANDARD" ]]; then
    # Use standard disk partitioning
    ( 
      # ESP partition
      echo o    # Create new partition table
      echo Y    # Confirm partition table
      disk_create_partition "$disk_esp_size" EF00

      # root partition
      if [[ $disk_root_size = $free_space ]]; then 
        root_size=    # Use 100% of the free space
      else 
        root_size=$disk_root_size
      fi 
      disk_create_partition "$root_size" 8300

      # /home on the same disk
      if [[ $disk_separate_home = false ]]; then
        if [[ $disk_home_size = $free_space ]]; then 
          home_size=    # Use 100% of the free space
        else 
          home_size=$disk_home_size
        fi 
        disk_create_partition "$home_size" 8300
      fi

      echo w    # Save changes to disk
      echo Y    # Confirm changes
    ) | gdisk $disk_root >> commands.log 2>> errors.log

    if [[ $? -eq 0 ]]; then
      cecho "Standard disk partitioning | $disk_root: SUCCESS"
    else
      cecho "Standard disk partitioning | $disk_root: FAILED"
      exit 1
    fi

    if [[ $disk_separate_home = true ]]; then
      (
        # /home on the separate disk
        echo o
        echo Y

        if [[ $disk_home_size = $free_space ]]; then 
          home_size=    # Use 100% of the free space
        else 
          home_size=$disk_home_size
        fi 
        disk_create_partition "$home_size" 8300

        echo w
        echo Y
      ) | gdisk $disk_home >> commands.log 2>> errors.log

      if [[ $? -eq 0 ]]; then
        cecho "Standard disk partitioning | $disk_home: SUCCESS"
      else
        cecho "Standard disk partitioning | $disk_home: FAILED"
        exit 1
      fi
    fi
  fi


  if [[ $1 = "LVM" ]]; then
    # Use LVM only or LVM + LUKS
    local free=

    for cnt in ${!disk_lvm_root[@]}; do
      if [[ $cnt -eq 0 ]]; then
        (
          # ESP partition on the first disk from root LVM group
          echo o
          echo Y
          disk_create_partition "$disk_esp_size" EF00
          disk_create_partition "$free" 8E00
          echo w
          echo Y
        ) | gdisk ${disk_lvm_root[0]} >> commands.log 2>> errors.log
      else
        (
          echo o
          echo Y
          disk_create_partition "$free" 8E00
          echo w
          echo Y
        ) | gdisk ${disk_lvm_root[$cnt]} >> commands.log 2>> errors.log
      fi

      if [[ $? -eq 0 ]]; then
        cecho "LVM disk partitioning | ${disk_lvm_root[$cnt]}: SUCCESS"
      else
        cecho "LVM disk partitioning | ${disk_lvm_root[$cnt]}: FAILED"
        exit 1
      fi
    done

    for cnt in ${!disk_lvm_home[@]}; do
      (
        echo o
        echo Y
        disk_create_partition "$free" 8E00
        echo w
        echo Y
      ) | gdisk ${disk_lvm_home[$cnt]} >> commands.log 2>> errors.log

      if [[ $? -eq 0 ]]; then
        cecho "LVM disk partitioning | ${disk_lvm_home[$cnt]}: SUCCESS"
      else
        cecho "LVM disk partitioning | ${disk_lvm_home[$cnt]}: FAILED"
        exit 1
      fi
    done
  fi
}

disk_list_drives() {
  # Show all drives
  local models=($(fdisk -l | awk '$2 ~ "model" {print $3" "$4" "$5}'))
  if [[ $? -ne 0 || -z $models ]]; then
    cecho "[WARNING] Cannot get drive model!" >&2
  fi

  local sizes=($(fdisk -l | awk '($4 ~ "TiB" || $4 ~ "GiB" || $4 ~ "MiB") && $2 !~ "loop|mapper" {print $3" "$4}'))
  if [[ $? -ne 0 || -z $sizes ]]; then
    cecho "[WARNING] Cannot get drive size!" >&2
  fi
  
  local drives=($(lsblk | awk '$1 !~ "NAME|-" && $1 !~ /[0-9]/ && $6 !~ "lvm|crypt" || ($1 ~ /nvme/ && $1 !~ /p/) {print $1}'))
  if [[ $? -ne 0 || -z $drives ]]; then
    cecho "Get list of all drives: FAILED" >&2
    exit 1
  fi  

  local cnt=0
  local pos_cnt=0
  local disk_drives=()

  for drive in ${drives[@]}; do
    echo -n "${cnt}) " >&2
    echo -n "${models[$pos_cnt]} ${models[$((pos_cnt + 1))]} " >&2
    echo -n "| ${sizes[$pos_cnt]} ${sizes[$((pos_cnt + 1))]} | " >&2
    echo "$drive" >&2

    cnt=$((cnt + 1))
    pos_cnt=$((pos_cnt + 2))
    disk_drives+=("$drive")
  done

  echo "${disk_drives[@]}"  # return value
}

disk_root_drives() {
  # -- disk_use_lvm         -   config variable
  # -- disk_root            -   config variable
  # -- disk_separate_home   -   config variable

  local drives=("$@")

  # We want to read numbers only
  local user_choice=-1
  if [[ $disk_use_lvm = false ]]; then
    while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#drives[@]} ]]; do
      read -p "Choose root drive: " user_choice
    done

    disk_root="/dev/${drives[$user_choice]}"
    echo "$disk_root"   # return value
  fi


  if [[ $disk_use_lvm = true ]]; then
    while read -p "Choose root drives (Enter to continue): " user_choice; do
      # Catch empty string and invalid input
      if [[ -z $user_choice && ${#disk_lvm_root[@]} -gt 0 ]]; then
        break
      elif [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#drives[@]} ]]; then
        continue
      else
        # Add drive to LVM group
        disk_lvm_root+=(/dev/${drives[$user_choice]})
      fi
    done

    echo "${disk_lvm_root[@]}"  # return value
  fi
}

disk_home_drives() {
  # -- disk_use_lvm   -   config variable
  # -- disk_home      -   config variable

  local drives=("$@")

  local user_choice=-1
  if [[ $disk_use_lvm = false ]]; then
    # We want to read numbers only
    while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#drives[@]} ]]; do
      read -p "Choose /home drive: " user_choice
    done

    disk_home="/dev/${drives[$user_choice]}"
    echo "$disk_home"   # return value
  fi


  if [[ $disk_use_lvm = true ]]; then
    while read -p "Choose /home drives (Enter to continue): " user_choice; do
      # Catch empty string and invalid input
      if [[ -z $user_choice && ${#disk_lvm_home[@]} -gt 0 ]]; then
        break
      elif [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#drives[@]} ]]; then
        continue
      else
        # Add drive to LVM group
        disk_lvm_home+=(/dev/${drives[$user_choice]})
      fi
    done
  
    echo "${disk_lvm_home[@]}"  # return value
  fi
}

disk_part_size() {
  # We want to read numbers only
  local user_choice=-1
  while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 ]]; do
    read -p "Choose $1 size (GiB or 0 for 100%FREE): " user_choice
  done

  local disk_size=""
  if [[ user_choice -eq 0 ]]; then
    disk_size=100FREE   # Use 100% of free space
  else
    disk_size="${user_choice}G"
  fi

  echo "$disk_size"   # return value
}

disk_part_mkfs() {
  yes | mkfs.$2 $1 >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "$3 Partition format ($2): SUCCESS"
  else
    cecho "$3 partition format ($2): FAILED"
    exit 1
  fi
}

disk_lvm_pv() {
  if [[ $1 = "ROOT" ]]; then
    local drives_root=()
    for cnt in ${!disk_lvm_root[@]}; do
      # Partition on the drive with ESP
      if [[ $cnt -eq 0 ]]; then
        drives_root+=(${disk_lvm_root[$cnt]}2)
        yes | pvcreate -ff ${disk_lvm_root[$cnt]}2 >> commands.log 2>> errors.log
      fi

      # Every next root partition
      if [[ $cnt -gt 0 && ${#disk_lvm_root[@]} -gt 1 ]]; then
        drives_root+=(${disk_lvm_root[$cnt]}1)
        yes | pvcreate -ff ${disk_lvm_root[$cnt]}1 >> commands.log 2>> errors.log
      fi

      if [[ $? -eq 0 ]]; then
        cecho "LVM Physical Volume (${drives_root[$cnt]}) create: SUCCESS" >&2
      else
        cecho "LVM Physical Volume (${drives_root[$cnt]}) create: FAILED" >&2
        exit 1
      fi
    done

    echo "${drives_root[@]}"    # return value
  fi

  if [[ $1 = "HOME" ]]; then
    local drives_home=()
    for cnt in ${!disk_lvm_home[@]}; do
      drives_home+=(${disk_lvm_home[$cnt]}1)
      yes | pvcreate -ff ${disk_lvm_home[$cnt]}1 >> commands.log 2>> errors.log

      if [[ $? -eq 0 ]]; then
        cecho "LVM Physical Volume (${drives_home[$cnt]}) create: SUCCESS" >&2
      else
        cecho "LVM Physical Volume (${drives_home[$cnt]}) create: FAILED" >&2
        exit 1
      fi
    done

    echo "${drives_home[@]}"    # return value
  fi
}

disk_lvm_vg() {
  yes | vgcreate $1 $2 >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "LVM Volume Group ($1) create: SUCCESS"
  else
    cecho "LVM Volume Group ($1) create: FAILED"
    exit 1
  fi
}

disk_lvm_lv() {
  local disk_space="100%FREE"
  if [[ ! $3 = "100FREE" ]]; then disk_space=$3; fi

  yes | lvcreate -l $disk_space -n $1 $2 >> commands.log 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "LVM Logical Volume ($1) create: SUCCESS"
  else
    cecho "LVM Logical Volume ($1) create: FAILED"
    exit 1
  fi
}

disk_luks_part() {
  echo $disk_luks_pass | cryptsetup -q luksFormat --type luks2 $1 >> commands.log 2>> errors.log
  
  if [[ $? -eq 0 ]]; then
    cecho "Encrypted partition ($1) create: SUCCESS" >&2
  else
    cecho "Encrypted partition ($1) create: FAILED" >&2
    exit 1
  fi

  echo $disk_luks_pass | cryptsetup luksOpen $1 $disk_luks_root_name >> commands.log 2>> errors.log
  root_part=/dev/mapper/$disk_luks_root_name

  if [[ $? -eq 0 ]]; then
    cecho "Decrypt partition ($1) and ready it to mount: SUCCESS" >&2
  else
    cecho "Decrypt partition ($1) and ready it to mount: FAILED" >&2
    exit 1
  fi

  echo "$root_part"   # return value
}

disk_part_mount() {
  mount $1 $2
  if [[ $? -eq 0 ]]; then
    cecho "$3 partition ($1) mount: SUCCESS"
  else
    cecho "$3 partition ($1) mount: FAILED"
    exit 1
  fi
}

disk_post_install_sync() {
  sync >> commands.log 2>> errors.log

  local mounts=$(lsblk | awk '$1 !~ "NAME|loop|sr" && $6 ~ "lvm|crypt|part" {print $7}' | tr -d '\├\─')
  if [[ -n $mounts ]]; then umount -l $mounts >> commands.log 2>> errors.log; fi
}


# -----------------------------------------------------------------------------
# -- BASE SYSTEM
# -----------------------------------------------------------------------------

os_cpu_microcode() {  
  if [[ $1 = "amd" ]]; then
    pacstrap /mnt amd-ucode 2>> errors.log
  fi

  if [[ $1 = "intel" ]]; then
    pacstrap /mnt intel-ucode 2>> errors.log
  fi
}

os_kernel_type() {
  if [[ $1 = "default" ]]; then
    pacstrap /mnt base base-devel linux linux-firmware linux-headers dhcpcd vim git 2>> errors.log
  else
    pacstrap /mnt base base-devel linux-${1} linux-firmware linux-${1}-headers dhcpcd vim git 2>> errors.log
  fi

  if [[ $? -eq 0 ]]; then
    cecho "Download base packages: SUCCESS"
  else
    cecho "Download base packages: FAILED"
    exit 1
  fi

  os_cpu_microcode "$2"
}

os_initramfs() {
  if [[ $disk_use_lvm = true ]]; then
    if [[ $disk_use_luks = true ]]; then hooks="lvm2 encrypt"
    else hooks="lvm2"; fi

    pacstrap /mnt lvm2 2>> errors.log
    arch-chroot /mnt /bin/bash -c "sed -i 's/\(HOOKS=(.*\)block\(.*\))/\1block ${hooks}\2)/' /etc/mkinitcpio.conf" 2>> errors.log
    if [[ $? -eq 0 ]]; then
      cecho "[CHROOT] Add hooks (${hooks[@]}) to mkinitcpio.conf: SUCCESS"
    else
      cecho "[CHROOT] Add hooks (${hooks[@]}) to mkinitcpio.conf]: FAILED"
      exit 1
    fi

    if [[ $1 = "default" ]]; then
      arch-chroot /mnt /bin/bash -c "mkinitcpio -p linux" 2>> errors.log
    else
      arch-chroot /mnt /bin/bash -c "mkinitcpio -p linux-${1}" 2>> errors.log
    fi

    if [[ $? -eq 0 ]]; then
      cecho "[CHROOT] Create initial ramdisk: SUCCESS"
    else
      cecho "[CHROOT] Create initial ramdisk: FAILED"
      exit 1
    fi
  fi
}

os_enable_dhcp() {
  arch-chroot /mnt /bin/bash -c "systemctl enable dhcpcd" 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "[CHROOT] Enable DHCP daemon (dhcpcd): SUCCESS"
  else
    cecho "[CHROOT] Enable DHCP daemon (dhcpcd): FAILED"
  fi
}

os_set_timezone() {
  arch-chroot /mnt /bin/bash -c "ln -sf /usr/share/zoneinfo/${1} /etc/localtime" 2>> errors.log
  arch-chroot /mnt /bin/bash -c "hwclock --systohc" 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "[CHROOT] Timezone (${1}) set: SUCCESS"
  else
    cecho "[CHROOT] Timezone (${1}) set: FAILED"
  fi
}

os_set_locale() {
  arch-chroot /mnt /bin/bash -c "sed -i 's/^#${1}\(.*\)$/${1}\1/' /etc/locale.gen" 2>> errors.log
  arch-chroot /mnt /bin/bash -c "locale-gen" 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "[CHROOT] Locale ($1) generation: SUCCESS"
  else
    cecho "[CHROOT] Locale ($1) generation: FAILED"
  fi
}

os_set_hostname() {
  arch-chroot /mnt /bin/bash -c "echo '${1}' > /etc/hostname" 2>> errors.log
  arch-chroot /mnt /bin/bash -c "echo '127.0.0.1 ${1}.localdomain ${1}' >> /etc/hosts" 2>> errors.log

  cecho "[CHROOT] Hostname ${1} assigned to this machine"
}

os_create_account() {
  if [[ -n $1 && ! $1 = "root" ]]; then
    # Default user groups
    if [[ -z $3 ]]; then 3="users"; fi

    if [[ $3 == *sudo* ]]; then
      arch-chroot /mnt /bin/bash -c "groupadd sudo" >> commands.log 2>> errors.log
      arch-chroot /mnt /bin/bash -c "sed -i '/^# %sudo/s/^# //' /etc/sudoers" >> commands.log 2>> errors.log
    fi

    arch-chroot /mnt /bin/bash -c "useradd -mG $3 -s /bin/bash $1" >> commands.log 2>> errors.log
    if [[ $? -eq 0 ]]; then
      cecho "[CHROOT] User ($1) acount create: SUCCESS"
    else
      cecho "[CHROOT] User ($1) acount create: FAILED"
    fi
  else
    cecho "[WARNING] User account has not been created"
  fi


  if [[ $? -eq 0 || $1 = "root" ]]; then
    # Set user's password only if account was created successfully
    arch-chroot /mnt /bin/bash -c "echo '${1}:${2}' | chpasswd" 2>> errors.log

    if [[ $? -eq 0 ]]; then
      cecho "[CHROOT] ${1} password set: SUCCESS"
    else
      cecho "[CHROOT] ${1} password set: FAILED"
    fi
  fi
}

os_bootloader() {
  # Bootloader
  arch-chroot /mnt /bin/bash -c "bootctl install" 2>> errors.log
  if [[ $? -eq 0 ]]; then
    cecho "[CHROOT] Bootloader install: SUCCESS"
  else
    cecho "[CHROOT] Bootloader install: FAILED"
    exit 1
  fi

  arch-chroot /mnt /bin/bash -c "echo 'default arch' > /boot/loader/loader.conf" 2>> errors.log
  arch-chroot /mnt /bin/bash -c "echo 'title Arch Linux' > /boot/loader/entries/arch.conf" 2>> errors.log
  if [[ $1 = "default" ]]; then
    arch-chroot /mnt /bin/bash -c "echo 'linux /vmlinuz-linux' >> /boot/loader/entries/arch.conf" 2>> errors.log
    arch-chroot /mnt /bin/bash -c "echo 'initrd /initramfs-linux.img' >> /boot/loader/entries/arch.conf" 2>> errors.log
  else
    arch-chroot /mnt /bin/bash -c "echo 'linux /vmlinuz-linux-${1}' >> /boot/loader/entries/arch.conf" 2>> errors.log
    arch-chroot /mnt /bin/bash -c "echo 'initrd /initramfs-linux-${1}.img' >> /boot/loader/entries/arch.conf" 2>> errors.log
  fi

  # amd-ucode
  if [[ $2 = "amd" ]]; then
    arch-chroot /mnt /bin/bash -c "echo 'initrd /amd-ucode.img' >> /boot/loader/entries/arch.conf" 2>> errors.log
  fi

  # intel-ucode
  if [[ $2 = "intel" ]]; then
    arch-chroot /mnt /bin/bash -c "echo 'initrd /intel-ucode.img' >> /boot/loader/entries/arch.conf" 2>> errors.log
  fi

  if [[ $disk_use_lvm = true ]]; then
    if [[ $disk_use_luks = true ]]; then
      luks_drive_uuid=$(arch-chroot )
      arch-chroot /mnt /bin/bash -c "echo 'options cryptdevice=UUID=$(blkid /dev/${disk_lvm_root_group}/${disk_lvm_root_volume} | awk -F '["]' '{print $2}'):${disk_luks_root_name} root=/dev/mapper/${disk_luks_root_name} rw' >> /boot/loader/entries/arch.conf" 2>> errors.log
    else
      arch-chroot /mnt /bin/bash -c "echo 'options root=/dev/mapper/${disk_lvm_root_group}-${disk_lvm_root_volume} rw' >> /boot/loader/entries/arch.conf" 2>> errors.log
    fi
  else 
    # Standard partition schema bootloader config
    arch-chroot /mnt /bin/bash -c "echo 'options root=UUID=$(blkid $root_part | awk -F '["]' '{print $2}') rw' >> /boot/loader/entries/arch.conf" 2>> errors.log
  fi


  cecho "[CHROOT] Bootloader config done."
}

os_change_shell() {
  if [[ -n $2 ]]; then
    local shell_flag=false
    case $2 in
      "bash")
        cecho "${2} already installed"
        shell_flag=false
        ;;
      "zsh")
        pacstrap /mnt $2 2>> errors.log
        shell_flag=true
        ;;
      "fish")
        pacstrap /mnt $2 lynx 2>> errors.log
        shell_flag=true
        ;;
      *)
        cecho "${2} install: FAILED"
        shell_flag=false
        ;;
    esac


    if [[ $shell_flag = true ]]; then
      arch-chroot /mnt /bin/bash -c "usermod --shell /bin/${2} ${1}" 2>> errors.log
    fi 

    if [[ $? -eq 0 ]]; then
      cecho "${2} install: SUCCESS"
    else
      cecho "${2} install: FAILED"
    fi
    
    cecho "ADDITIONAL SHELL CONFIGURATION MAY BE NEEDED"
  fi
}

os_install_de() {
  # -- DESKTOP ENV -- #
  if [[ $1 = true || -n $2 ]]; then
    pacstrap /mnt xorg xorg-xinit xterm 2>> errors.log
    if [[ $? -eq 0 ]]; then
      cecho "Xorg install: SUCCESS"
    else
      cecho "Xorg install: FAILED"
      exit 1
    fi

    local de=""
    local dm=""
    case $2 in
      "plasma")
        pacstrap /mnt plasma plasma-wayland-session kde-applications 2>> errors.log
        de=Plasma
        dm=SDDM 
        ;;
      "gnome") 
        pacstrap /mnt gnome gnome-shell-extensions 2>> errors.log
        de=GNOME
        dm=GDM
        ;;
      "xfce") 
        pacstrap /mnt xfce4 xfce4-goodies sddm 2>> errors.log
        de=XFCE
        dm=SDDM
        ;;
      *) 
        cecho "Desktop Environment install: FAILED"
        return -1
        ;;
    esac

    if [[ $? -eq 0 ]]; then
      cecho "$de install: SUCCESS"
      cecho "REMEMBER TO ENABLE $dm AFTER REBOOT (systemctl enable --now ${dm,,})"
    else
      cecho "$de install: FAILED"
      exit 1
    fi
    cecho "INSTALLING ADDITIONAL VIDEO DRIVERS MAY BE NEEDED"
  fi
}


###############################################################################
# -- MAIN FUNCTION
###############################################################################

main() {
  # Load default config file only in non-interactive mode, 
  # only without custom one provided
  if [[ $1 -eq 0 ]]; then load_config; fi
  
  check_uefi_boot
  

  #############################################################################
  # -- NETWORK
  # ---------------------------------------------------------------------------

  echo
  cecho "Checking for network..."
  local interfaces=$(net_scan_interfaces)
  local active_int=$(net_check_interfaces "$interfaces")
  if [[ -n $active_int ]]; then
    local int_status=$(net_interface_status "$active_int")
  fi

  # If it returns -1, we know that we passed only one interface and it's down
  if [[ $active_int -eq -1 ]]; then cecho "Get $interfaces status: FAILED"; fi


  if [[ $interactive_mode = true ]]; then
    # If interactive mode is enabled, we don't care what's in the config
    local ints=($interfaces)

    # We want to read numbers only
    local user_choice=-1
    while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 || $user_choice -gt ${#ints[@]} ]]; do
      read -p "Choose interface: " user_choice
    done

    active_int=${ints[$user_choice]}
    int_status=$(cat /sys/class/net/"$active_int"/operstate)
  fi


  if [[ $int_status = "up" ]]; then
    cecho "Interface $active_int: $int_status"
  else
    # IP address config on interface
    if [[ $interactive_mode = true ]]; then
      local ipa="invalid"
      while [[ $ipa = "invalid" ]]; do
        IFS='./' read -rp "IP address (CIDR): " a b c d e
        ipa=$(validate_ip_address $a $b $c $d $e)
      done
      net_ip_address=$ipa   # config variable
      
      ipa="invalid"
      while [[ $ipa = "invalid" ]]; do
        IFS='./' read -rp "Default gateway: " a b c d
        ipa=$(validate_ip_address $a $b $c $d)
      done
      net_gateway=$ipa      # config variable

      ipa="invalid"
      while [[ $ipa = "invalid" ]]; do
        IFS='./' read -rp "DNS server: " a b c d
        ipa=$(validate_ip_address $a $b $c $d)
      done
      net_nameserver=($ipa)   # config variable
    fi

    net_interface_config "$active_int"
  fi

  net_check_connection


  #############################################################################
  # -- STORAGE
  # ---------------------------------------------------------------------------
  # -- disk_use_lvm     -   config variable
  # -- disk_use_luks    -   config variable
  # -- disk_lvm_root    -   config variable
  # -- disk_lvm_home    -   config variable
  # -- disk_root        -   config variable
  # -- disk_home        -   config variable
  # -- disk_esp_size    -   config variable
  # -- disk_root_size   -   config variable
  # -- disk_home_size   -   config variable
  # ---------------------------------------------------------------------------
  # -- PARTITIONING
  # ---------------------------------------------------------------------------

  if [[ $interactive_mode = true ]]; then
    # Ugly workaround, to be changed
    disk_use_lvm=false
    disk_use_luks=false
    disk_lvm_root=()
    disk_lvm_home=()


    # We want Y/N only
    local answer=-1
    while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
      read -p "Do you want to use LVM? (Y/N): " answer
    done
    if [[ ${answer,,} =~ ^y(es)?$ ]]; then disk_use_lvm=true; fi
    
    answer=-1
    while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
      read -p "Do you want to use LUKS? (Y/N): " answer
    done
    if [[ ${answer,,} =~ ^y(es)?$ ]]; then 
      if [[ $disk_use_lvm = false ]]; then
        cecho "[WARNING] LUKS supported only in the LVM mode!"
        cecho "LVM mode has been enabled."
        disk_use_lvm=true 
      fi
      
      disk_use_luks=true
    fi


    # We want to read numbers only
    local user_choice=-1
    while [[ -n ${user_choice//[0-9]/} || $user_choice -lt 0 ]]; do
      read -p "Choose ESP size (MiB): " user_choice
    done
    disk_esp_size="${user_choice}M"


    local disk_drives=$(disk_list_drives)
    disk_drives=($disk_drives)

    local root_drives=$(disk_root_drives "${disk_drives[@]}")
    root_drives=($root_drives)


    if [[ $disk_use_lvm = false ]]; then
      # We want Y/N only
      answer=-1
      while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
        read -p "Use separate drive for /home? (Y/N): " answer
      done
      if [[ ${answer,,} =~ ^y(es)?$ ]]; then disk_separate_home=true 
      else disk_separate_home=false; fi
    fi

    if [[ $disk_separate_home = true || $disk_use_lvm = true ]]; then
      local home_drives=$(disk_home_drives "${disk_drives[@]}")
      home_drives=($home_drives)
    fi


    if [[ $disk_use_lvm = true ]]; then
      disk_root=${root_drives[0]}
      disk_lvm_root=("${root_drives[@]}")
      disk_lvm_home=("${home_drives[@]}")
    else
      disk_root=$root_drives
      disk_home=$home_drives
    fi

    disk_root_size=$(disk_part_size "root")
    disk_home_size=$(disk_part_size "home")
  else
    disk_root=${disk_lvm_root[0]}
  fi


  local esp_part=""
  local root_part=""
  local home_part=""

  # It does only matter without LVM or LUKS
  home_part=${disk_home}1
  if [[ ${disk_root} =~ /nvme/ ]]; then
    esp_part=${disk_root}p1     # eg. /dev/nvme0n1p1
    if [[ $disk_separate_home = true ]]; then
      root_part=${disk_root}p2    # eg. /dev/nvme0n1p2
    else
      root_part=${disk_root}p2    # eg. /dev/nvme0n1p2
      home_part=${disk_root}p3    # eg. /dev/nvme0n1p3
    fi
  else
    esp_part=${disk_root}1      # eg. /dev/sda1
    if [[ $disk_separate_home = true ]]; then
      root_part=${disk_root}2     # eg. /dev/sda2
    else
      root_part=${disk_root}2     # eg. /dev/sda2
      home_part=${disk_root}3     # eg. /dev/sda3
    fi
  fi

  if [[ $disk_use_lvm = true ]]; then
    disk_format_drive "LVM"
    partprobe >> commands.log 2>> errors.log
  else
    disk_format_drive "STANDARD"
    partprobe >> commands.log 2>> errors.log
  fi


  # ---------------------------------------------------------------------------
  # -- FORMATTING
  # ---------------------------------------------------------------------------
  # -- disk_root_fs           -   config variable
  # -- disk_lvm_root_group    -   config variable
  # -- disk_lvm_root_volume   -   config variable
  # -- disk_home_fs           -   config variable
  # -- disk_lvm_home_group    -   config variable
  # -- disk_lvm_home_volume   -   config variable
  # -- disk_use_lvm           -   config variable
  # -- disk_use_luks          -   config variable
  # -- disk_luks_pass         -   config variable
  # -- disk_luks_root_name    -   config variable
  # ---------------------------------------------------------------------------

  if [[ $disk_use_lvm = true ]]; then
    root_drives=()
    home_drives=()
    
    if [[ $interactive_mode = true ]]; then
      read -p "Choose root group name (eg. root): " disk_lvm_root_group
      read -p "Choose home group name (eg. home): " disk_lvm_home_group
    fi

    root_drives=$(disk_lvm_pv "ROOT")
    home_drives=$(disk_lvm_pv "HOME")

    disk_lvm_vg "$disk_lvm_root_group" "$root_drives" 
    disk_lvm_vg "$disk_lvm_home_group" "$home_drives" 

    if [[ $interactive_mode = true ]]; then
      read -p "Choose root volume name (eg. proot): " disk_lvm_root_volume
      read -p "Choose home volume name (eg. phome): " disk_lvm_home_volume
    fi

    disk_lvm_lv "$disk_lvm_root_volume" "$disk_lvm_root_group" "$disk_root_size"
    disk_lvm_lv "$disk_lvm_home_volume" "$disk_lvm_home_group" "$disk_home_size"

    root_part=/dev/$disk_lvm_root_group/$disk_lvm_root_volume
    home_part=/dev/$disk_lvm_home_group/$disk_lvm_home_volume
  fi

  
  if [[ $disk_use_luks = true ]]; then
    if [[ $interactive_mode = true ]]; then 
      read -s -p "Choose encryption password: " disk_luks_pass
      echo
      read -p "Choose LUKS root partition name (eg. cryptroot): " disk_luks_root_name
    fi

    root_part=$(disk_luks_part "$root_part")
  fi


  disk_part_mkfs "$esp_part" "vfat" "ESP"

  if [[ $interactive_mode = true ]]; then
    read -p "Choose root filesystem (ext4, xfs, btrfs etc.): " disk_root_fs
    read -p "Choose /home filesystem (ext4, xfs, btrfs etc.): " disk_home_fs
  fi

  disk_part_mkfs "$root_part" "$disk_root_fs" "root"
  disk_part_mkfs "$home_part" "$disk_home_fs" "home"

  disk_part_mount "$root_part" "/mnt" "Root"
  
  mkdir /mnt/boot
  disk_part_mount "$esp_part" "/mnt/boot" "Boot"

  mkdir /mnt/home
  disk_part_mount "$home_part" "/mnt/home" "Home"


  #############################################################################
  # -- BASE SYSTEM
  # ---------------------------------------------------------------------------

  echo
  cecho "Checking for packages..."

  # Download base of the system
  if [[ $interactive_mode = true ]]; then
    read -p "Choose kernel (eg. default | zen, vfio, lts etc.): " os_kernel 
    if [[ -z $os_kernel ]]; then os_kernel="default"; fi
  fi

  os_kernel_type "$os_kernel" "$os_cpu"

  # Generate fstab using UUID
  genfstab -U /mnt > /mnt/etc/fstab
  if [[ $? -eq 0 ]]; then
    cecho "UUID fstab generation: SUCCESS"
  else
    cecho "UUID fstab generation: FAILED"
    exit 1
  fi


  # ---------------------------------------------------------------------------
  # -- INSIDE THE OS
  # ---------------------------------------------------------------------------

  os_initramfs "$os_kernel"
  os_enable_dhcp

  # Timezone settings
  if [[ $interactive_mode = true ]]; then
    read -p "Choose timezone (eg. Europe/Warsaw): " os_timezone
  fi
  os_set_timezone "$os_timezone"

  # Locale settings
  if [[ $interactive_mode = true ]]; then
    read -p "Choose system locale (eg. en_US.UTF-8): " os_locale
  fi
  os_set_locale "$os_locale"

  # Hostname
  if [[ $interactive_mode = true ]]; then
    read -p "Choose hostname: " os_hostname
  fi
  os_set_hostname "$os_hostname"


  if [[ $interactive_mode = true ]]; then
    read -s -p "Choose root password: " os_root_pass
    echo
  fi
  os_create_account "root" "$os_root_pass"

  # User account
  if [[ $interactive_mode = true ]]; then
    read -p "Choose user name: " os_user_name
    read -s -p "Choose user password: " os_user_pass
    echo
    read -p "Choose user groups (default: users): " os_user_groups
  fi
  os_create_account "$os_user_name" "$os_user_pass" "$os_user_groups"

  os_bootloader "$os_kernel"

  if [[ $interactive_mode = true ]]; then
    read -s -p "Choose shell to install: " os_shell
    echo
  fi
  os_change_shell "root" "$os_shell"
  os_change_shell "$os_user_name" "$os_shell"


  if [[ $interactive_mode = true ]]; then
    answer=-1
    while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
      read -p "Do you want to install Xorg? (Y/N): " answer
    done
    if [[ ${answer,,} =~ ^y(es)?$ ]]; then os_install_xorg=true; fi

    if [[ $os_install_xorg = true ]]; then
      answer=-1
      while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
        read -p "Do you want to install Desktop Environment? (Y/N): " answer
      done
      if [[ ${answer,,} =~ ^y(es)?$ ]]; then
        read -p "Choose DE to install (eg. plasma, gnome, xfce): " os_desktop
      fi
    fi
  fi

  if [[ -n $os_install_xorg ]]; then 
    os_install_de "$os_install_xorg" 
  fi

  if [[ -n $os_desktop ]]
    os_install_de "$os_install_xorg" "$os_desktop"
  fi


  logs_dir="arch-install-logs"
  mkdir /mnt/root/"$logs_dir"
  cp *.log /mnt/root/"$logs_dir"/

  answer=-1
  while [[ ! ${answer,,} =~ ^y(es)?$ && ! ${answer,,} =~ ^n(o)?$ ]]; do
    echo "Install logs are located in /root/$logs_dir/"
    read -p "Do you want to reboot now? (Y/N): " answer
  done
  if [[ ${answer,,} =~ ^y(es)?$ ]]; then
    disk_post_install_sync
    reboot >> commands.log 2>> errors.log
  else
    sync >> commands.log 2>> errors.log
  fi
}

handle_flags "$@"
main "$#"